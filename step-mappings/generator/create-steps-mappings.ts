import { ensureDirectoryStructureExists } from '../../tools/fs/ensure-directory-structure-exists';
import { getExportedFunctionsIn, FuncInfo } from '../../tools/fs/get-exported-functions-in';
import { getFileName } from '../../tools/fs/get-filename';
import { getFilePathWithoutExtension } from '../../tools/fs/get-filepath-without-extension';
import { getFuncNameFrom } from '../../tools/fs/get-func-name-from-file-name';
import { getJsDocCommentsOf } from '../../tools/fs/get-jsdoc-of-function';
import { getRelativePathOf } from '../../tools/fs/get-relative-path-from';
import { slash } from '../../tools/fs/slash';
import { surround } from '../../tools/string/surround-with-quote';
import { upperCaseFirstLetter } from '../../tools/string/upper-case-first-letter';
import { config } from '../config';
import { EOL } from 'os';
import { PathLike, writeFileSync } from 'fs';

let exportIndex = -1;
function nextIndex(): number {
  exportIndex += 1;
  return exportIndex;
}
export const createStepsMapping = (path: PathLike): { from: (stepFiles: string[]) => void } => {
  ensureDirectoryStructureExists(path.toString());
  writeFileSync(path, 'importing steps and creating given/when/then mappings...');
  return {
    from: (stepFiles: string[]): void => {
      const lines: string[] = [];
      lines.push(
        `// this file was auto-generated by '${getRelativePathOf(__filename).from(
          config.stepsMappingFile
        )}'`
      );
      lines.push(...createImports());
      lines.push('');
      lines.push(...createInterfaces());
      lines.push(...createStepMappingsFrom(stepFiles).forStep('given'));
      lines.push(...createStepMappingsFrom(stepFiles).forStep('when'));
      lines.push(...createStepMappingsFrom(stepFiles).forStep('then'));
      lines.push(...createStepMappingsFrom(stepFiles).forStep('but'));
      lines.push('');
      writeFileSync(path, lines.join(EOL));
    },
  };
};

function createInterfaces(): string[] {
  const lines = [];
  lines.push('export interface StepMappings {');
  lines.push(`${config.tab}[index: string]: (stepname: string) => Promise<void>;`);
  lines.push('}');
  return lines;
}

function createImports(): string[] {
  const stepsBarrelRelativePath = getRelativePathOf(config.stepsBarrelFile).from(
    config.stepsMappingFile
  );
  const lines: string[] = [];
  lines.push(
    `import * as step from ${config.quoteMark}${slash(
      getFilePathWithoutExtension(stepsBarrelRelativePath)
    )}${config.quoteMark};`
  );
  return lines;
}

export interface StepMapping {
  stepSentence: string;
  stepFunc: string;
}

function createStepMappingsFrom(stepFiles: string[]): { forStep: (step: string) => string[] } {
  return {
    forStep: (step: string): string[] => {
      const lines: string[] = [];
      const stepMappings = getStepMappingsFrom(stepFiles)
        .forStep(step)
        .sort((a: StepMapping, b: StepMapping): number =>
          a.stepSentence.localeCompare(b.stepSentence)
        );

      if (stepMappings.length === 0) {
        lines.push(`export const ${step}StepMappings = {};`);
        lines.push(
          `export type ${upperCaseFirstLetter(step)}Step = keyof typeof ${step}StepMappings;`
        );
        return lines;
      }

      lines.push(`export const ${step}StepMappings = {`);
      stepMappings.forEach((stepMapping: StepMapping): void => {
        lines.push(
          `${config.tab}${surround(stepMapping.stepSentence).with(config.quoteMark)}: step.${
            stepMapping.stepFunc
          },`
        );
      });
      lines.push('};');
      lines.push(
        `export type ${upperCaseFirstLetter(step)}Step = keyof typeof ${step}StepMappings;`
      );
      return lines;
    },
  };
}

function getStepMappingsFrom(stepFiles: string[]): { forStep: (step: string) => StepMapping[] } {
  return {
    forStep: (step: string): StepMapping[] => {
      const results: StepMapping[] = [];
      stepFiles.forEach((filePath: string): void => {
        const fileName = getFileName(filePath) || `defaultStep${nextIndex()}`;
        const defaultExportName = getFuncNameFrom(fileName);
        getExportedFunctionsIn(filePath).forEach((funcInfo: FuncInfo): void => {
          getJsDocCommentsOf(funcInfo)
            .filter((comment: string): boolean => comment.includes(`@${step}`))
            .map((comment: string): { stepSentence: string; stepFunc: string } => {
              const firstIndex = comment.indexOf('(') + 2;
              const lastIndex = comment.lastIndexOf(')') - 1;
              const stepSentence = comment.substring(firstIndex, lastIndex);
              const stepFunc =
                funcInfo.functionName === 'default' ? defaultExportName : funcInfo.functionName;
              return { stepSentence, stepFunc };
            })
            .forEach((stepMapping: StepMapping): number => results.push(stepMapping));
        });
      });
      return results;
    },
  };
}
